<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Typing Playground â€” Maze Munch</title>
  <style>
    :root{
      --bg1:#A8D8F0;
      --bg2:#c8f3ff;
      --bg3:#e7fff6;
      --purple:#5b5fc7;
      --ink:#23304a;
      --panel: rgba(255,255,255,.85);
      --panelBorder: rgba(91,95,199,.18);
      --wall:#1f4cff;
      --wallGlow: rgba(31,76,255,.35);
      --mazeBg:#061227;
      --dot:#ffd166;
      --exit:#ff6b6b;
      --pac:#ffe66d;
    }
    body{
      margin:0;
      font-family: "Comic Sans MS", system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 60%, var(--bg3) 100%);
      color: var(--ink);
      text-align:center;
    }
    .wrap{ max-width:1100px; margin:0 auto; padding:18px 14px 30px; }
    .title{
      margin: 10px auto 6px;
      font-size: clamp(34px, 5vw, 56px);
      letter-spacing: 1px;
      color: var(--purple);
      text-shadow: 0 2px 0 rgba(255,255,255,.7);
      font-weight: 900;
    }
    .subtitle{
      margin: 0 0 12px;
      font-size: clamp(14px, 2.2vw, 18px);
      color: #3f4aa8;
      font-weight: 800;
      line-height: 1.35;
    }
    .card{
      background: var(--panel);
      border: 2px solid rgba(255,255,255,.95);
      border-radius: 18px;
      box-shadow: 0 10px 30px rgba(17,38,74,.12);
      padding: 14px 14px 18px;
      backdrop-filter: blur(6px);
    }
    .topbar{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      border: 2px solid var(--panelBorder);
      color: var(--purple);
      font-weight: 900;
    }
    .btnRow{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
    button{
      font-size: 18px;
      font-weight: 900;
      padding: 10px 16px;
      border-radius: 14px;
      border: 0;
      cursor:pointer;
      background: #ffd166;
      box-shadow: 0 6px 0 rgba(0,0,0,.08);
    }
    button:hover{ filter: brightness(0.98); transform: translateY(1px); }
    button:active{ transform: translateY(2px); }

    .help{
      max-width: 980px;
      margin: 10px auto 12px;
      padding: 12px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.92);
      border: 2px solid var(--panelBorder);
      font-weight: 900;
      color: #3f4aa8;
      line-height: 1.35;
    }
    .kbd{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(91,95,199,.12);
      border: 1px solid rgba(91,95,199,.25);
      font-weight: 900;
      color: var(--purple);
    }

    .boardWrap{
      display:flex;
      justify-content:center;
      margin-top: 10px;
    }
    canvas{
      width: min(920px, 96vw);
      height: auto;
      border-radius: 18px;
      background: #061227;
      box-shadow: 0 14px 32px rgba(0,0,0,.18);
      border: 3px solid rgba(255,255,255,.65);
    }

    .status{
      font-size: 28px;
      font-weight: 900;
      margin-top: 10px;
      min-height: 40px;
      color: #3f4aa8;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">Typing Playground</div>
    <div class="subtitle">Play. Practise. Power Up! A fun way to build your typing power at Chongfu School.</div>

    <div class="card">
      <div class="topbar">
        <div class="pill" id="modePill">Maze Munch</div>
        <div class="pill" id="timePill">Time: 60</div>
      </div>

      <div class="help">
        âœ… <span class="kbd">Type the letter</span> on a dot <span class="kbd">next to Pac-Man</span> to move and eat it.<br/>
        ðŸŽ¯ Reach the <span class="kbd">RED exit</span> before time runs out! (No score needed.)
      </div>

      <div class="boardWrap">
        <canvas id="c" width="920" height="560" aria-label="Maze typing game"></canvas>
      </div>

      <div class="status" id="status"></div>

      <div class="btnRow">
        <button id="startBtn">Start</button>
        <button id="restartBtn">Restart</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= MAZE LAYOUT =========
  // Legend:
  // 1 = wall
  // 0 = path (will have a letter-dot unless it's start/exit)
  // S = start
  // E = exit
  //
  // This is a simple, kid-friendly maze (not too tight).
  const MAZE = [
    "111111111111111111111",
    "1S0000000100000000001",
    "1011111110101111111101".replace(/0/g,'0').replace(/11/g,'11'), // keep as string; harmless line
  ];

  // We'll build a fixed grid directly (more control):
  const GRID = [
    "111111111111111111111",
    "1S0000000100000000001",
    "1011111100101111110101",
    "1000000100001000000101",
    "1111100111111011110101",
    "1000100000000010000101",
    "1010111110111110111101",
    "1010000010000010000001",
    "1011111011111011111101",
    "1000001000001000000001",
    "1111101110111011111101",
    "10000000001000000000E1",
    "111111111111111111111"
  ];

  // ========= GAME SETTINGS =========
  const TOTAL_SECONDS = 60;
  const LETTERS = "abcdefghijklmnopqrstuvwxyz";

  // ========= CANVAS SETUP =========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const timePill = document.getElementById("timePill");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");

  const rows = GRID.length;
  const cols = GRID[0].length;

  // Cell sizing to fit canvas nicely
  const pad = 16;
  const cell = Math.floor(Math.min(
    (canvas.width - pad*2) / cols,
    (canvas.height - pad*2) / rows
  ));
  const originX = Math.floor((canvas.width - cols*cell) / 2);
  const originY = Math.floor((canvas.height - rows*cell) / 2);

  // ========= STATE =========
  let running = false;
  let timeLeft = TOTAL_SECONDS;
  let secondTimer = null;

  let startPos = null;
  let exitPos = null;

  // dots: map "r,c" -> letter (only on path cells with dots)
  let dots = new Map();

  // pacman position
  let pr = 0, pc = 0;

  // ========= HELPERS =========
  const keyOf = (r,c) => `${r},${c}`;
  const isWall = (r,c) => GRID[r][c] === "1";
  const isStart = (r,c) => GRID[r][c] === "S";
  const isExit  = (r,c) => GRID[r][c] === "E";
  const inBounds = (r,c) => r>=0 && r<rows && c>=0 && c<cols;

  function resetGame(){
    running = false;
    clearInterval(secondTimer);
    timeLeft = TOTAL_SECONDS;
    timePill.textContent = `Time: ${timeLeft}`;
    statusEl.textContent = "";

    // find start + exit
    startPos = null; exitPos = null;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if (isStart(r,c)) startPos = {r,c};
        if (isExit(r,c)) exitPos  = {r,c};
      }
    }
    pr = startPos.r; pc = startPos.c;

    // place dots with letters on every path cell except start/exit
    dots = new Map();
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const ch = GRID[r][c];
        if (ch === "0") {
          dots.set(keyOf(r,c), LETTERS[Math.floor(Math.random()*LETTERS.length)]);
        }
      }
    }
    draw();
  }

  function startGame(){
    if (running) return;
    running = true;
    statusEl.textContent = "Go! Type the letter on a dot next to Pac-Man!";
    secondTimer = setInterval(() => {
      if (!running) return;
      timeLeft--;
      timePill.textContent = `Time: ${timeLeft}`;
      if (timeLeft <= 0){
        running = false;
        statusEl.textContent = "â° Timeâ€™s up! Press Restart and try again.";
      }
    }, 1000);
  }

  function winGame(){
    running = false;
    clearInterval(secondTimer);
    statusEl.textContent = "ðŸŽ‰ You escaped the maze! Well done!";
  }

  function adjacentTargets(){
    // Returns adjacent dot cells with their letters
    const dirs = [
      {dr:-1,dc:0}, {dr:1,dc:0}, {dr:0,dc:-1}, {dr:0,dc:1}
    ];
    const out = [];
    for (const d of dirs){
      const nr = pr + d.dr, nc = pc + d.dc;
      if (!inBounds(nr,nc) || isWall(nr,nc)) continue;

      const k = keyOf(nr,nc);
      // dot exists only on "0" cells (paths). Start/exit have none.
      if (dots.has(k)){
        out.push({r:nr,c:nc,letter:dots.get(k)});
      } else {
        // allow moving onto exit even without a dot
        if (isExit(nr,nc)) out.push({r:nr,c:nc,letter:null,exit:true});
      }
    }
    return out;
  }

  function handleKey(e){
    if (!running) return;

    const k = e.key;
    if (!k || k.length !== 1) return;

    const pressed = k.toLowerCase();

    // If pressed matches a letter-dot adjacent, move there and eat it
    const adj = adjacentTargets();

    // exit move (optional): allow Enter to go into exit? but keep consistent: must type letter, so exit is reached by stepping onto exit cell from adjacent path.
    const match = adj.find(t => t.letter === pressed);

    if (match){
      pr = match.r; pc = match.c;
      dots.delete(keyOf(pr,pc)); // eat dot
      draw();
      return;
    }

    // Also allow stepping into exit if adjacent and player presses ANY key shown? Keep simple:
    // If exit is adjacent, they can move into it by typing the letter on the adjacent dot that leads there.
    // But sometimes exit is adjacent directly from path with no dot on exit cell, so just allow a special key: "e"
    // Better: if exit is adjacent and pressed is "e", move into exit (kid-friendly).
    const exitAdj = adj.find(t => t.exit);
    if (exitAdj && pressed === "e"){
      pr = exitAdj.r; pc = exitAdj.c;
      draw();
      winGame();
    }
  }

  // ========= DRAWING =========
  function cellRect(r,c){
    const x = originX + c*cell;
    const y = originY + r*cell;
    return {x,y,w:cell,h:cell};
  }

  function draw(){
    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = getCSS("--mazeBg");
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // subtle glow border
    ctx.strokeStyle = "rgba(255,255,255,.25)";
    ctx.lineWidth = 6;
    ctx.strokeRect(8,8,canvas.width-16,canvas.height-16);

    // walls + paths
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const {x,y,w,h} = cellRect(r,c);
        const ch = GRID[r][c];

        if (ch === "1"){
          // wall
          ctx.fillStyle = getCSS("--wallGlow");
          ctx.fillRect(x-1,y-1,w+2,h+2);

          ctx.fillStyle = getCSS("--wall");
          roundRect(ctx, x+2, y+2, w-4, h-4, 8);
          ctx.fill();
        } else {
          // path (dark)
          ctx.fillStyle = "rgba(255,255,255,.02)";
          ctx.fillRect(x,y,w,h);
        }

        // exit
        if (ch === "E"){
          ctx.fillStyle = "rgba(255,107,107,.25)";
          roundRect(ctx, x+4, y+4, w-8, h-8, 10); ctx.fill();
          ctx.strokeStyle = "rgba(255,107,107,.9)";
          ctx.lineWidth = 3;
          roundRect(ctx, x+6, y+6, w-12, h-12, 10); ctx.stroke();

          ctx.fillStyle = "rgba(255,255,255,.95)";
          ctx.font = `900 ${Math.floor(cell*0.45)}px Comic Sans MS, Arial`;
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("EXIT", x+w/2, y+h/2);
        }
      }
    }

    // dots with letters
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `900 ${Math.floor(cell*0.44)}px ui-monospace, Menlo, Consolas, monospace`;

    for (const [k,letter] of dots.entries()){
      const [r,c] = k.split(",").map(Number);
      const {x,y,w,h} = cellRect(r,c);

      // dot circle
      ctx.fillStyle = "rgba(255,209,102,.18)";
      ctx.beginPath();
      ctx.arc(x+w/2, y+h/2, Math.max(6, cell*0.28), 0, Math.PI*2);
      ctx.fill();

      // letter
      ctx.fillStyle = "rgba(255,209,102,.95)";
      ctx.fillText(letter.toUpperCase(), x+w/2, y+h/2);
    }

    // Pac-Man
    drawPacman(pr,pc);

    // Hint: show letters adjacent (optional visual cue)
    drawAdjHint();
  }

  function drawPacman(r,c){
    const {x,y,w,h} = cellRect(r,c);
    const cx = x+w/2, cy = y+h/2;
    const radius = Math.max(10, cell*0.38);

    // mouth animation based on time
    const t = Date.now()/200;
    const mouth = 0.35 + 0.12*Math.abs(Math.sin(t));

    ctx.fillStyle = getCSS("--pac");
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,radius,mouth,Math.PI*2-mouth,false);
    ctx.closePath();
    ctx.fill();

    // eye
    ctx.fillStyle = "rgba(0,0,0,.7)";
    ctx.beginPath();
    ctx.arc(cx + radius*0.15, cy - radius*0.35, Math.max(2, radius*0.10), 0, Math.PI*2);
    ctx.fill();
  }

  function drawAdjHint(){
    const adj = adjacentTargets();
    if (!adj.length) return;

    // Glow outline around adjacent letter-dots (teaching cue)
    for (const t of adj){
      if (t.exit) continue;
      const {x,y,w,h} = cellRect(t.r,t.c);
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 3;
      roundRect(ctx, x+6, y+6, w-12, h-12, 10);
      ctx.stroke();
    }

    // If exit adjacent, show small "Press E to exit" helper (kid-friendly)
    const exitAdj = adj.find(a => a.exit);
    if (exitAdj){
      statusEl.textContent = "Exit is near! Press E to step into EXIT.";
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function getCSS(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  // ========= EVENTS =========
  startBtn.addEventListener("click", startGame);
  restartBtn.addEventListener("click", () => { resetGame(); startGame(); });
  document.addEventListener("keydown", handleKey);

  // init
  resetGame();
})();
</script>
</body>
</html>
