<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Munch</title>
  <style>
    :root{
      /* Pastel sky */
      --sky1:#bfe8ff;
      --sky2:#d7f3ff;
      --sky3:#eafcff;

      --purple:#6b6fe8;
      --purple2:#8a8df2;
      --ink:#2b3352;

      --panel: rgba(255,255,255,.86);
      --panelBorder: rgba(107,111,232,.18);

      /* Maze palette (still Pac-man-ish but softer) */
      --mazeBg:#0c1a33;          /* deep navy */
      --wall:#4f7dff;           /* softer blue */
      --wallGlow: rgba(79,125,255,.35);

      --dotGlow: rgba(255,219,138,.18);
      --dotText: rgba(255,219,138,.96);

      --exit:#ff7f9e;           /* pastel red-pink */
      --pac:#ffe88a;            /* pastel yellow */

      /* Keyboard */
      --key:#f7fbff;
      --keyBorder:#c9d9ef;
      --lit1:#ffe9a8;
      --lit2:#ff9bb0;

      --shadow: 0 12px 32px rgba(22,34,68,.14);
    }

    body{
      margin:0;
      font-family: "Comic Sans MS", system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      background: linear-gradient(180deg, var(--sky1) 0%, var(--sky2) 60%, var(--sky3) 100%);
      color: var(--ink);
      text-align:center;
    }

    .wrap{ max-width:1100px; margin:0 auto; padding:18px 14px 28px; }

    .title{
      margin: 8px auto 6px;
      font-size: clamp(38px, 5.4vw, 64px);
      letter-spacing: 1px;
      color: var(--purple);
      text-shadow: 0 3px 0 rgba(255,255,255,.8);
      font-weight: 900;
    }
    .subtitle{
      margin: 0 0 10px;
      font-size: clamp(14px, 2.2vw, 18px);
      color: #4450d6;
      font-weight: 800;
      line-height: 1.35;
    }

    .card{
      background: var(--panel);
      border: 2px solid rgba(255,255,255,.95);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 14px 14px 18px;
      backdrop-filter: blur(6px);
    }

    /* Center time */
    .centerBar{
      display:flex;
      justify-content:center;
      margin: 8px 0 10px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      border: 2px solid var(--panelBorder);
      color: var(--purple);
      font-weight: 900;
      font-size: 18px;
      box-shadow: 0 6px 0 rgba(0,0,0,.05);
    }

    .help{
      max-width: 980px;
      margin: 10px auto 12px;
      padding: 12px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.92);
      border: 2px solid var(--panelBorder);
      font-weight: 900;
      color: #4450d6;
      line-height: 1.4;
    }
    .kbd{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(107,111,232,.12);
      border: 1px solid rgba(107,111,232,.25);
      font-weight: 900;
      color: var(--purple);
    }

    .boardWrap{
      display:flex;
      justify-content:center;
      margin-top: 10px;
    }
    canvas{
      width: min(920px, 96vw);
      height: auto;
      border-radius: 18px;
      background: var(--mazeBg);
      box-shadow: 0 14px 32px rgba(0,0,0,.18);
      border: 3px solid rgba(255,255,255,.75);
    }

    .status{
      font-size: 26px;
      font-weight: 900;
      margin-top: 10px;
      min-height: 40px;
      color: #4450d6;
    }

    .btnRow{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
    button{
      font-size: 18px;
      font-weight: 900;
      padding: 10px 16px;
      border-radius: 14px;
      border: 0;
      cursor:pointer;
      background: #ffe18b;
      box-shadow: 0 6px 0 rgba(0,0,0,.08);
    }
    button:hover{ filter: brightness(0.98); transform: translateY(1px); }
    button:active{ transform: translateY(2px); }

    /* ===== Assisting Keyboard (always visible) ===== */
    .keyboard{
      margin: 14px auto 0;
      max-width: 980px;
      background: rgba(255,255,255,.75);
      border: 2px solid rgba(255,255,255,.95);
      border-radius: 18px;
      padding: 14px 12px;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
    }
    .row{
      display:flex;
      justify-content:center;
      gap: 8px;
      margin: 7px 0;
      flex-wrap: nowrap;
    }
    .key{
      min-width: 46px;
      height: 48px;
      border-radius: 14px;
      background: var(--key);
      border: 2px solid var(--keyBorder);
      box-shadow: 0 4px 0 rgba(0,0,0,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      color: var(--ink);
      user-select:none;
      position:relative;
      font-size: 18px;
      padding: 0 6px;
    }
    .key.wide{ min-width: 86px; }
    .key.xwide{ min-width: 122px; }
    .key.space{ min-width: 320px; }

    .key.lit{
      background: linear-gradient(180deg, var(--lit1), var(--lit2));
      border-color: rgba(255,155,176,.75);
      color: #1b2233;
      box-shadow: 0 0 0 4px rgba(255,155,176,.18), 0 8px 0 rgba(0,0,0,.08);
      transform: translateY(-1px);
    }

    .key .sub{
      position:absolute;
      bottom: 4px;
      right: 6px;
      font-size: 10px;
      opacity:.55;
      font-weight: 800;
    }

    @media (max-width: 760px){
      .key.space{ min-width: 230px; }
      .key{ min-width: 38px; height: 44px; border-radius: 12px; }
      .key.wide{ min-width: 70px; }
      .key.xwide{ min-width: 98px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">Maze Munch</div>
    <div class="subtitle">Play. Practise. Power Up! A fun way to build your typing power at Chongfu School.</div>

    <div class="card">

      <!-- Time centered -->
      <div class="centerBar">
        <div class="pill" id="timePill">Time: 60</div>
      </div>

      <div class="help" id="helpBox">
        âœ… <span class="kbd">Type the letter</span> on a dot <span class="kbd">next to Pac-Man</span> to move and eat it.<br/>
        ðŸŽ¯ Reach the <span class="kbd">RED exit</span> before time runs out! (No score needed.)
      </div>

      <div class="boardWrap">
        <canvas id="c" width="920" height="560" aria-label="Maze typing game"></canvas>
      </div>

      <div class="status" id="status"></div>

      <!-- Assisting keyboard (always visible) -->
      <div class="keyboard" aria-label="Assisting keyboard">
        <div class="row">
          <div class="key" data-key="q">Q</div><div class="key" data-key="w">W</div><div class="key" data-key="e">E</div>
          <div class="key" data-key="r">R</div><div class="key" data-key="t">T</div><div class="key" data-key="y">Y</div>
          <div class="key" data-key="u">U</div><div class="key" data-key="i">I</div><div class="key" data-key="o">O</div>
          <div class="key" data-key="p">P</div>
        </div>
        <div class="row">
          <div class="key" data-key="a">A</div><div class="key" data-key="s">S</div><div class="key" data-key="d">D</div>
          <div class="key" data-key="f">F</div><div class="key" data-key="g">G</div><div class="key" data-key="h">H</div>
          <div class="key" data-key="j">J</div><div class="key" data-key="k">K</div><div class="key" data-key="l">L</div>
        </div>
        <div class="row">
          <div class="key" data-key="z">Z</div><div class="key" data-key="x">X</div><div class="key" data-key="c">C</div>
          <div class="key" data-key="v">V</div><div class="key" data-key="b">B</div><div class="key" data-key="n">N</div>
          <div class="key" data-key="m">M</div>
        </div>
        <div class="row">
          <div class="key" data-key=".">.</div>
          <div class="key" data-key=",">,</div>
          <div class="key" data-key="_">_</div>
          <div class="key" data-key="!">!</div>
          <div class="key" data-key="@">@</div>
          <div class="key space" data-key=" "><span>SPACE</span><span class="sub">sp</span></div>
        </div>
      </div>

      <div class="btnRow">
        <button id="startBtn">Start</button>
        <button id="restartBtn">Restart</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Maze grid =====
  const GRID = [
    "111111111111111111111",
    "1S0000000100000000001",
    "1011111100101111110101",
    "1000000100001000000101",
    "1111100111111011110101",
    "1000100000000010000101",
    "1010111110111110111101",
    "1010000010000010000001",
    "1011111011111011111101",
    "1000001000001000000001",
    "1111101110111011111101",
    "10000000001000000000E1",
    "111111111111111111111"
  ];

  const TOTAL_SECONDS = 60;
  const LETTERS = "abcdefghijklmnopqrstuvwxyz";

  // canvas
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // UI
  const timePill = document.getElementById("timePill");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");

  // keyboard keys
  const keyEls = Array.from(document.querySelectorAll(".key"));

  const rows = GRID.length;
  const cols = GRID[0].length;

  const pad = 16;
  const cell = Math.floor(Math.min(
    (canvas.width - pad*2) / cols,
    (canvas.height - pad*2) / rows
  ));
  const originX = Math.floor((canvas.width - cols*cell) / 2);
  const originY = Math.floor((canvas.height - rows*cell) / 2);

  // state
  let running = false;
  let timeLeft = TOTAL_SECONDS;
  let secondTimer = null;

  let startPos = null;
  let exitPos = null;

  let dots = new Map();  // "r,c" -> letter
  let pr = 0, pc = 0;

  // helpers
  const keyOf = (r,c) => `${r},${c}`;
  const inBounds = (r,c) => r>=0 && r<rows && c>=0 && c<cols;
  const isWall = (r,c) => GRID[r][c] === "1";
  const isStart = (r,c) => GRID[r][c] === "S";
  const isExit  = (r,c) => GRID[r][c] === "E";

  function getCSS(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function clearKeyLights(){
    keyEls.forEach(k => k.classList.remove("lit"));
  }

  function lightKeyFor(ch){
    clearKeyLights();
    const matches = keyEls.filter(k => k.dataset.key === ch);
    matches.forEach(m => m.classList.add("lit"));
  }

  function resetGame(){
    running = false;
    clearInterval(secondTimer);
    timeLeft = TOTAL_SECONDS;
    timePill.textContent = `Time: ${timeLeft}`;
    statusEl.textContent = "Press Start to begin!";
    clearKeyLights();

    // find start + exit
    startPos = null; exitPos = null;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if (isStart(r,c)) startPos = {r,c};
        if (isExit(r,c))  exitPos  = {r,c};
      }
    }
    pr = startPos.r; pc = startPos.c;

    // dots on every "0"
    dots = new Map();
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if (GRID[r][c] === "0"){
          dots.set(keyOf(r,c), LETTERS[Math.floor(Math.random()*LETTERS.length)]);
        }
      }
    }

    draw();
    updateKeyboardHint(); // light an adjacent letter if possible
  }

  function startGame(){
    if (running) return;
    running = true;
    statusEl.textContent = "Go! Type the glowing letter next to Pac-Man!";
    secondTimer = setInterval(() => {
      if (!running) return;
      timeLeft--;
      timePill.textContent = `Time: ${timeLeft}`;
      if (timeLeft <= 0){
        running = false;
        statusEl.textContent = "â° Timeâ€™s up! Press Restart and try again.";
        clearKeyLights();
      }
    }, 1000);
  }

  function winGame(){
    running = false;
    clearInterval(secondTimer);
    statusEl.textContent = "ðŸŽ‰ You escaped the maze! Well done!";
    clearKeyLights();
  }

  function adjacentTargets(){
    const dirs = [
      {dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}
    ];
    const out = [];
    for (const d of dirs){
      const nr = pr + d.dr, nc = pc + d.dc;
      if (!inBounds(nr,nc) || isWall(nr,nc)) continue;
      const k = keyOf(nr,nc);
      if (dots.has(k)){
        out.push({r:nr,c:nc,letter:dots.get(k)});
      } else if (isExit(nr,nc)){
        out.push({r:nr,c:nc,exit:true});
      }
    }
    return out;
  }

  function updateKeyboardHint(){
    if (!running) {
      // still show a hint key when idle (nice for kids)
      const adj = adjacentTargets();
      const firstLetter = adj.find(a => a.letter)?.letter;
      if (firstLetter) lightKeyFor(firstLetter);
      return;
    }
    const adj = adjacentTargets();
    const firstLetter = adj.find(a => a.letter)?.letter;
    if (firstLetter) {
      lightKeyFor(firstLetter);
    } else {
      clearKeyLights();
    }
  }

  function handleKey(e){
    if (!running) return;

    const k = e.key;
    if (!k || k.length !== 1) return;
    const pressed = k.toLowerCase();

    const adj = adjacentTargets();
    const match = adj.find(t => t.letter === pressed);

    if (match){
      pr = match.r; pc = match.c;
      dots.delete(keyOf(pr,pc)); // eat dot
      draw();

      // check win
      if (isExit(pr,pc)) winGame();

      updateKeyboardHint();
      return;
    }

    // allow stepping into exit with "e" if adjacent (kid-friendly)
    const exitAdj = adj.find(a => a.exit);
    if (exitAdj && pressed === "e"){
      pr = exitAdj.r; pc = exitAdj.c;
      draw();
      winGame();
    }
  }

  function cellRect(r,c){
    const x = originX + c*cell;
    const y = originY + r*cell;
    return {x,y,w:cell,h:cell};
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function draw(){
    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = getCSS("--mazeBg");
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // subtle border
    ctx.strokeStyle = "rgba(255,255,255,.25)";
    ctx.lineWidth = 6;
    ctx.strokeRect(8,8,canvas.width-16,canvas.height-16);

    // walls + paths + exit
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const {x,y,w,h} = cellRect(r,c);
        const ch = GRID[r][c];

        if (ch === "1"){
          ctx.fillStyle = getCSS("--wallGlow");
          ctx.fillRect(x-1,y-1,w+2,h+2);

          ctx.fillStyle = getCSS("--wall");
          roundRect(ctx, x+2, y+2, w-4, h-4, 8);
          ctx.fill();
        } else {
          ctx.fillStyle = "rgba(255,255,255,.02)";
          ctx.fillRect(x,y,w,h);
        }

        if (ch === "E"){
          ctx.fillStyle = "rgba(255,127,158,.25)";
          roundRect(ctx, x+4, y+4, w-8, h-8, 10); ctx.fill();
          ctx.strokeStyle = "rgba(255,127,158,.9)";
          ctx.lineWidth = 3;
          roundRect(ctx, x+6, y+6, w-12, h-12, 10); ctx.stroke();

          ctx.fillStyle = "rgba(255,255,255,.95)";
          ctx.font = `900 ${Math.floor(cell*0.45)}px Comic Sans MS, Arial`;
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("EXIT", x+w/2, y+h/2);
        }
      }
    }

    // dots letters
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `900 ${Math.floor(cell*0.44)}px ui-monospace, Menlo, Consolas, monospace`;

    for (const [k,letter] of dots.entries()){
      const [r,c] = k.split(",").map(Number);
      const {x,y,w,h} = cellRect(r,c);

      ctx.fillStyle = getCSS("--dotGlow");
      ctx.beginPath();
      ctx.arc(x+w/2, y+h/2, Math.max(6, cell*0.28), 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = getCSS("--dotText");
      ctx.fillText(letter.toUpperCase(), x+w/2, y+h/2);
    }

    // Pac-Man
    drawPacman(pr,pc);

    // Highlight adjacent dot squares slightly (visual assist)
    drawAdjHint();
  }

  function drawPacman(r,c){
    const {x,y,w,h} = cellRect(r,c);
    const cx = x+w/2, cy = y+h/2;
    const radius = Math.max(10, cell*0.38);

    const t = Date.now()/200;
    const mouth = 0.35 + 0.12*Math.abs(Math.sin(t));

    ctx.fillStyle = getCSS("--pac");
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,radius,mouth,Math.PI*2-mouth,false);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,.65)";
    ctx.beginPath();
    ctx.arc(cx + radius*0.15, cy - radius*0.35, Math.max(2, radius*0.10), 0, Math.PI*2);
    ctx.fill();
  }

  function drawAdjHint(){
    const adj = adjacentTargets();
    if (!adj.length) return;

    for (const t of adj){
      if (t.exit) continue;
      const {x,y,w,h} = cellRect(t.r,t.c);
      ctx.strokeStyle = "rgba(255,255,255,.20)";
      ctx.lineWidth = 3;
      roundRect(ctx, x+6, y+6, w-12, h-12, 10);
      ctx.stroke();
    }

    const exitAdj = adj.find(a => a.exit);
    if (exitAdj){
      statusEl.textContent = "Exit is near! Press E to step into EXIT.";
    }
  }

  // events
  startBtn.addEventListener("click", () => { startGame(); updateKeyboardHint(); });
  restartBtn.addEventListener("click", () => { resetGame(); startGame(); updateKeyboardHint(); });
  document.addEventListener("keydown", handleKey);

  // init
  resetGame();
})();
</script>
</body>
</html>
