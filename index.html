<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Munch</title>

  <style>
    :root{
      --ink:#2b3352;
      --title:#6b6fe8;
      --titleDark:#4450d6;

      --panel: rgba(255,255,255,.86);
      --panelBorder: rgba(107,111,232,.18);
      --shadow: 0 14px 34px rgba(22,34,68,.16);

      --mazeBg:#0c1a33;
      --wall:#4f7dff;
      --wallGlow: rgba(79,125,255,.35);

      --dotGlow: rgba(255,219,138,.18);
      --dotText: rgba(255,219,138,.96);

      --exit:#ff7f9e;
      --pac:#ffe88a;

      --key:#f7fbff;
      --keyBorder:#c9d9ef;
      --keyInk:#2b3352;

      --lit1:#ffe9a8;
      --lit2:#ff9bb0;

      --radius: 18px;
    }

    body{
      margin:0;
      font-family: "Comic Sans MS", system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      color: var(--ink);
      text-align:center;
      background: #f3f7ff;
      overflow-x:hidden;
    }

    /* Soft decorative background */
    .bg{
      position: fixed;
      inset: 0;
      z-index:-10;
      background:
        radial-gradient(circle at 15% 20%, rgba(107,111,232,.22) 0%, rgba(107,111,232,0) 45%),
        radial-gradient(circle at 85% 25%, rgba(255,155,176,.22) 0%, rgba(255,155,176,0) 50%),
        radial-gradient(circle at 25% 85%, rgba(255,233,168,.28) 0%, rgba(255,233,168,0) 55%),
        linear-gradient(180deg, #fff 0%, #f3f7ff 40%, #eef4ff 100%);
    }

    .wrap{
      max-width: 1120px;
      margin: 0 auto;
      padding: 16px 14px 28px;
    }

    .title{
      margin: 6px 0 2px;
      font-size: clamp(34px, 5vw, 62px);
      font-weight: 900;
      letter-spacing: .5px;
      color: var(--title);
      text-shadow: 0 3px 0 rgba(255,255,255,.9);
    }
    .subtitle{
      margin: 0 0 10px;
      font-size: clamp(13px, 2vw, 18px);
      color: var(--titleDark);
      font-weight: 900;
    }

    .card{
      background: var(--panel);
      border: 2px solid rgba(255,255,255,.95);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 18px;
      backdrop-filter: blur(8px);
    }

    /* Layout: Maze top, time middle, keyboard bottom */
    .gameCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 10px;
      margin-top: 8px;
    }

    .mazeFrame{
      width: min(1020px, 100%);
      border-radius: 20px;
      background: rgba(255,255,255,.74);
      border: 2px solid rgba(255,255,255,.95);
      box-shadow: 0 16px 34px rgba(0,0,0,.14);
      padding: 12px;
    }

    canvas{
      width: 100%;
      height: auto;
      display:block;
      border-radius: 16px;
      background: var(--mazeBg);
      border: 3px solid rgba(255,255,255,.75);
      box-shadow: 0 12px 22px rgba(0,0,0,.15);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 10px 18px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      border: 2px solid var(--panelBorder);
      color: var(--titleDark);
      font-weight: 900;
      font-size: 18px;
      min-width: 180px;
      box-shadow: 0 6px 0 rgba(0,0,0,.05);
    }

    .help{
      max-width: 980px;
      margin: 6px auto 8px;
      padding: 12px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.92);
      border: 2px solid var(--panelBorder);
      font-weight: 900;
      color: var(--titleDark);
      line-height: 1.4;
    }
    .kbd{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(107,111,232,.12);
      border: 1px solid rgba(107,111,232,.25);
      font-weight: 900;
      color: var(--title);
      white-space: nowrap;
    }

    .status{
      font-size: 20px;
      font-weight: 900;
      margin: 8px 0 0;
      min-height: 30px;
      color: var(--titleDark);
    }

    .btnRow{
      display:flex;
      gap: 12px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    button{
      font-size: 20px;
      font-weight: 900;
      padding: 12px 18px;
      border-radius: 16px;
      border: 0;
      cursor:pointer;
      background: #ffe18b;
      box-shadow: 0 6px 0 rgba(0,0,0,.10);
    }
    button:hover{ filter: brightness(0.98); transform: translateY(1px); }
    button:active{ transform: translateY(2px); }

    /* Keyboard centered */
    .keyboardWrap{
      width: min(760px, 100%);
      background: rgba(255,255,255,.82);
      border: 2px solid rgba(255,255,255,.95);
      border-radius: 18px;
      padding: 12px 12px 10px;
      box-shadow: 0 12px 22px rgba(0,0,0,.10);
    }

    .row{
      display:flex;
      justify-content:center;
      gap: 8px;
      margin: 7px 0;
      flex-wrap: nowrap;
    }
    .key{
      width: 46px;
      height: 46px;
      border-radius: 12px;
      background: var(--key);
      border: 2px solid var(--keyBorder);
      box-shadow: 0 4px 0 rgba(0,0,0,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      color: var(--keyInk);
      user-select:none;
      position:relative;
      padding: 0 6px;
    }
    .key.wide{ width: 76px; }
    .key.xwide{ width: 104px; }
    .key.space{ width: 240px; }
    .key.tiny{ width: 40px; }

    .key.dual{ font-size: 0; }
    .key .top{ position:absolute; top: 7px; left: 8px; font-size: 12px; font-weight: 900; opacity: .92; }
    .key .bot{ position:absolute; bottom: 7px; left: 8px; font-size: 12px; font-weight: 900; opacity: .86; }
    .key .center{ font-size: 18px; font-weight: 900; }

    .key.lit{
      background: linear-gradient(180deg, var(--lit1), var(--lit2));
      border-color: rgba(255,155,176,.75);
      color: #1b2233;
      box-shadow: 0 0 0 4px rgba(255,155,176,.18), 0 8px 0 rgba(0,0,0,.08);
      transform: translateY(-1px);
    }

    .kbdNote{
      margin-top: 8px;
      font-weight: 900;
      color: var(--titleDark);
      font-size: 14px;
      opacity: .95;
    }

    .hidden{ display:none !important; }

    @media (max-width: 760px){
      .row{ gap:6px; }
      .key{ width: 40px; height: 44px; }
      .key.wide{ width: 70px; }
      .key.xwide{ width: 92px; }
      .key.space{ width: 200px; }
    }
  </style>
</head>

<body>
  <div class="bg" aria-hidden="true"></div>

  <div class="wrap">
    <div class="title">Maze Munch</div>
    <div class="subtitle">A fun way to build your typing power at Chongfu School.</div>

    <div class="card">
      <div class="gameCol">
        <div class="mazeFrame">
          <canvas id="c" width="1020" height="560" aria-label="Maze typing game"></canvas>
        </div>

        <div class="pill" id="timePill">Time: 120</div>

        <div class="keyboardWrap hidden" id="keyboardWrap" aria-label="Assisting keyboard">
          <div class="row">
            <div class="key dual tiny" data-key="1" data-shift="!"><span class="top">!</span><span class="bot">1</span></div>
            <div class="key dual tiny" data-key="2" data-shift="@"><span class="top">@</span><span class="bot">2</span></div>
            <div class="key dual tiny" data-key="3" data-shift="#"><span class="top">#</span><span class="bot">3</span></div>
            <div class="key dual tiny" data-key="4" data-shift="$"><span class="top">$</span><span class="bot">4</span></div>
            <div class="key dual tiny" data-key="5" data-shift="%"><span class="top">%</span><span class="bot">5</span></div>
            <div class="key dual tiny" data-key="6" data-shift="^"><span class="top">^</span><span class="bot">6</span></div>
            <div class="key dual tiny" data-key="7" data-shift="&"><span class="top">&</span><span class="bot">7</span></div>
            <div class="key dual tiny" data-key="8" data-shift="*"><span class="top">*</span><span class="bot">8</span></div>
            <div class="key dual tiny" data-key="9" data-shift="("><span class="top">(</span><span class="bot">9</span></div>
            <div class="key dual tiny" data-key="0" data-shift=")"><span class="top">)</span><span class="bot">0</span></div>
            <div class="key dual tiny" data-key="-" data-shift="_"><span class="top">_</span><span class="bot">-</span></div>
            <div class="key dual tiny" data-key="=" data-shift="+"><span class="top">+</span><span class="bot">=</span></div>
            <div class="key xwide" data-key="Backspace"><span class="center">Backspace</span></div>
          </div>

          <div class="row">
            <div class="key wide" data-key="Tab"><span class="center">Tab</span></div>
            <div class="key" data-key="q"><span class="center">Q</span></div>
            <div class="key" data-key="w"><span class="center">W</span></div>
            <div class="key" data-key="e"><span class="center">E</span></div>
            <div class="key" data-key="r"><span class="center">R</span></div>
            <div class="key" data-key="t"><span class="center">T</span></div>
            <div class="key" data-key="y"><span class="center">Y</span></div>
            <div class="key" data-key="u"><span class="center">U</span></div>
            <div class="key" data-key="i"><span class="center">I</span></div>
            <div class="key" data-key="o"><span class="center">O</span></div>
            <div class="key" data-key="p"><span class="center">P</span></div>
            <div class="key dual tiny" data-key="[" data-shift="{"><span class="top">{</span><span class="bot">[</span></div>
            <div class="key dual tiny" data-key="]" data-shift="}"><span class="top">}</span><span class="bot">]</span></div>
          </div>

          <div class="row">
            <div class="key xwide" data-key="CapsLock"><span class="center">Caps</span></div>
            <div class="key" data-key="a"><span class="center">A</span></div>
            <div class="key" data-key="s"><span class="center">S</span></div>
            <div class="key" data-key="d"><span class="center">D</span></div>
            <div class="key" data-key="f"><span class="center">F</span></div>
            <div class="key" data-key="g"><span class="center">G</span></div>
            <div class="key" data-key="h"><span class="center">H</span></div>
            <div class="key" data-key="j"><span class="center">J</span></div>
            <div class="key" data-key="k"><span class="center">K</span></div>
            <div class="key" data-key="l"><span class="center">L</span></div>
            <div class="key dual tiny" data-key=";" data-shift=":"><span class="top">:</span><span class="bot">;</span></div>
            <div class="key dual tiny" data-key="'" data-shift="&quot;"><span class="top">"</span><span class="bot">'</span></div>
            <div class="key xwide" data-key="Enter"><span class="center">Enter</span></div>
          </div>

          <div class="row">
            <div class="key xwide" data-key="Shift"><span class="center">Shift</span></div>
            <div class="key" data-key="z"><span class="center">Z</span></div>
            <div class="key" data-key="x"><span class="center">X</span></div>
            <div class="key" data-key="c"><span class="center">C</span></div>
            <div class="key" data-key="v"><span class="center">V</span></div>
            <div class="key" data-key="b"><span class="center">B</span></div>
            <div class="key" data-key="n"><span class="center">N</span></div>
            <div class="key" data-key="m"><span class="center">M</span></div>
            <div class="key dual tiny" data-key="," data-shift="&lt;"><span class="top">&lt;</span><span class="bot">,</span></div>
            <div class="key dual tiny" data-key="." data-shift="&gt;"><span class="top">&gt;</span><span class="bot">.</span></div>
            <div class="key dual tiny" data-key="/" data-shift="?"><span class="top">?</span><span class="bot">/</span></div>
            <div class="key xwide" data-key="Shift"><span class="center">Shift</span></div>
          </div>

          <div class="row">
            <div class="key wide" data-key="Ctrl"><span class="center">Ctrl</span></div>
            <div class="key wide" data-key="Alt"><span class="center">Alt</span></div>
            <div class="key space" data-key=" "><span class="center">SPACE</span></div>
            <div class="key wide" data-key="Alt"><span class="center">Alt</span></div>
            <div class="key wide" data-key="Ctrl"><span class="center">Ctrl</span></div>
          </div>

          <div class="kbdNote" id="kbdNote">
            Tip: For <span class="kbd">!</span>, <span class="kbd">@</span>, <span class="kbd">_</span>, <span class="kbd">+</span> press <span class="kbd">Shift</span> + key.
          </div>
        </div>

        <div class="help hidden" id="helpBox">
          âœ… <span class="kbd">Type the letter</span> on a dot <span class="kbd">next to Pac-Man</span> to move and eat it.<br/>
          ðŸŽ¯ Reach the <span class="kbd">RED exit</span> before time runs out!
        </div>

        <div class="status" id="status">Choose Level 1 or Level 2 to begin!</div>

        <div class="btnRow" id="btnRow">
          <button id="level1Btn">Level 1 (Letters)</button>
          <button id="level2Btn">Level 2 (Symbols)</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== SETTINGS (as requested) =====
  const MAZE_CELLS_W = 13;      // Maze size: 13 Ã— 7
  const MAZE_CELLS_H = 7;

  const DOT_DENSITY = 0.65;     // Dot density
  const WALL_BREAK_CHANCE = 0.20; // within 0.18â€“0.22

  const LEVELS = {
    letters: { time: 120, set: "abcdefghijklmnopqrstuvwxyz" },
    symbols: { time: 180, set: "!.@,=-_+" }
  };
  const shiftMap = { "!":"1", "@":"2", "_":"-", "+":"=" };

  // ===== Canvas + UI =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const timePill = document.getElementById("timePill");
  const statusEl = document.getElementById("status");
  const helpBox  = document.getElementById("helpBox");
  const kbdNote  = document.getElementById("kbdNote");
  const keyboardWrap = document.getElementById("keyboardWrap");

  const level1Btn = document.getElementById("level1Btn");
  const level2Btn = document.getElementById("level2Btn");
  const btnRow = document.getElementById("btnRow");

  const keyEls = Array.from(document.querySelectorAll(".key"));

  // ===== Maze state =====
  let WALLS = []; // 2D: 1 wall, 0 path
  let rows = 0, cols = 0;

  let running = false;
  let timeLeft = LEVELS.letters.time;
  let secondTimer = null;

  let mode = "letters";
  let dots = new Map();    // "r,c" -> char
  let pr = 0, pc = 0;      // pac position in wall grid coords
  let startPos = null;
  let exitPos = null;

  const keyOf = (r,c) => `${r},${c}`;
  const inBounds = (r,c) => r>=0 && r<rows && c>=0 && c<cols;
  const isWall = (r,c) => WALLS[r]?.[c] === 1;

  function getCSS(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function clearKeyLights(){ keyEls.forEach(k => k.classList.remove("lit")); }
  function lightKey(match){
    const m = String(match);
    const hits = keyEls.filter(k => k.dataset.key === m || k.dataset.shift === m);
    hits.forEach(h => h.classList.add("lit"));
  }

  function randFrom(set){ return set[Math.floor(Math.random() * set.length)]; }

  // ===== Maze generation (kid-friendly) =====
  // Perfect maze (backtracker) + wall breaks to open it up.
  function generateMaze(){
    const w = MAZE_CELLS_W;
    const h = MAZE_CELLS_H;

    const visited = Array.from({length:h}, () => Array(w).fill(false));

    rows = 2*h + 1;
    cols = 2*w + 1;
    WALLS = Array.from({length: rows}, () => Array(cols).fill(1));

    // cell centers paths
    for(let cy=0; cy<h; cy++){
      for(let cx=0; cx<w; cx++){
        WALLS[2*cy+1][2*cx+1] = 0;
      }
    }

    function neighbors(cx,cy){
      const out = [];
      if (cy>0) out.push([cx,cy-1, 0,-1]);
      if (cy<h-1) out.push([cx,cy+1, 0, 1]);
      if (cx>0) out.push([cx-1,cy,-1, 0]);
      if (cx<w-1) out.push([cx+1,cy, 1, 0]);
      for(let i=out.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [out[i],out[j]] = [out[j],out[i]];
      }
      return out;
    }

    // Start from left-middle cell
    let cx = 0;
    let cy = Math.floor(h/2);
    visited[cy][cx] = true;

    const stack = [[cx,cy]];
    while(stack.length){
      const [x,y] = stack[stack.length-1];
      const nbrs = neighbors(x,y).filter(([nx,ny]) => !visited[ny][nx]);

      if(nbrs.length === 0){
        stack.pop();
        continue;
      }

      const [nx,ny,dx,dy] = nbrs[0];
      const wx = 2*x+1 + dx;
      const wy = 2*y+1 + dy;
      WALLS[wy][wx] = 0;

      visited[ny][nx] = true;
      stack.push([nx,ny]);
    }

    // Add "wall breaks" to make it more open/easier
    for(let r=1; r<rows-1; r++){
      for(let c=1; c<cols-1; c++){
        if (WALLS[r][c] === 1 && Math.random() < WALL_BREAK_CHANCE){
          WALLS[r][c] = 0;
        }
      }
    }

    // Start & exit positions (inside border)
    startPos = { r: 2*Math.floor(h/2)+1, c: 1 };
    exitPos  = { r: 2*Math.floor(h/2)+1, c: cols-2 };

    WALLS[startPos.r][startPos.c] = 0;
    WALLS[exitPos.r][exitPos.c] = 0;
  }

  function buildDots(){
    dots = new Map();
    const set = LEVELS[mode].set;

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if (isWall(r,c)) continue;
        if (r===startPos.r && c===startPos.c) continue;
        if (r===exitPos.r && c===exitPos.c) continue;

        // place dots at requested density
        if (Math.random() <= DOT_DENSITY){
          dots.set(keyOf(r,c), randFrom(set));
        }
      }
    }

    // Ensure a few dots right next to start (so it feels immediate)
    const near = [
      [startPos.r, startPos.c+1],
      [startPos.r-1, startPos.c],
      [startPos.r+1, startPos.c]
    ];
    for(const [r,c] of near){
      if (inBounds(r,c) && !isWall(r,c) && !(r===exitPos.r && c===exitPos.c)){
        dots.set(keyOf(r,c), randFrom(set));
      }
    }
  }

  // ===== Timing + round control =====
  function setTime(seconds){
    timeLeft = seconds;
    timePill.textContent = `Time: ${timeLeft}`;
  }

  function startTimer(){
    running = true;
    clearInterval(secondTimer);
    secondTimer = setInterval(() => {
      if (!running) return;
      timeLeft--;
      timePill.textContent = `Time: ${timeLeft}`;
      if (timeLeft <= 0){
        endRound("â° Timeâ€™s up! Choose Level 1 or Level 2 to try again.");
      }
    }, 1000);
  }

  function showGameUI(){
    keyboardWrap.classList.remove("hidden");
    helpBox.classList.remove("hidden");
    btnRow.classList.add("hidden");
    canvas.scrollIntoView({ behavior: "smooth", block: "center" });
  }

  function endRound(message){
    running = false;
    clearInterval(secondTimer);
    clearKeyLights();
    btnRow.classList.remove("hidden");
    statusEl.textContent = message;
  }

  function startLevel(newMode){
    mode = newMode;

    generateMaze();  // new maze each time
    buildDots();

    pr = startPos.r; pc = startPos.c;

    if (mode === "letters"){
      helpBox.innerHTML =
        `âœ… <span class="kbd">Type the letter</span> on a dot <span class="kbd">next to Pac-Man</span> to move and eat it.<br/>
         ðŸŽ¯ Reach the <span class="kbd">RED exit</span> before time runs out!`;
      statusEl.textContent = "Level 1: Type letters to move!";
      kbdNote.classList.add("hidden");
      setTime(LEVELS.letters.time);
    } else {
      helpBox.innerHTML =
        `âœ… <span class="kbd">Type the symbol</span> on a dot <span class="kbd">next to Pac-Man</span> to move and eat it.<br/>
         ðŸŽ¯ Reach the <span class="kbd">RED exit</span> before time runs out!`;
      statusEl.textContent = "Level 2: Type symbols to move!";
      kbdNote.classList.remove("hidden");
      setTime(LEVELS.symbols.time);
    }

    showGameUI();
    draw();
    updateKeyboardHint();
    startTimer();
  }

  function winGame(){
    endRound("ðŸŽ‰ You escaped the maze! Choose Level 1 or Level 2 to play again (new maze each time).");
  }

  // ===== Movement logic =====
  function adjacentTargets(){
    const dirs = [{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
    const out = [];
    for (const d of dirs){
      const nr = pr + d.dr, nc = pc + d.dc;
      if (!inBounds(nr,nc) || isWall(nr,nc)) continue;

      const k = keyOf(nr,nc);
      if (dots.has(k)) out.push({r:nr,c:nc,ch:dots.get(k)});
      else if (nr===exitPos.r && nc===exitPos.c) out.push({r:nr,c:nc,exit:true});
    }
    return out;
  }

  function updateKeyboardHint(){
    clearKeyLights();
    const adj = adjacentTargets();
    const chars = adj.filter(a => a.ch).map(a => a.ch);

    for (const ch of chars){
      if (shiftMap[ch]){
        lightKey("Shift");
        lightKey(shiftMap[ch]);
      } else {
        lightKey(ch);
      }
    }
  }

  function handleKey(e){
    if (!running) return;

    let pressed = e.key;
    if (!pressed) return;

    // If key is a single character, normalise to lower for letters
    if (pressed.length === 1) pressed = pressed.toLowerCase();

    const adj = adjacentTargets();
    const match = adj.find(t => t.ch === pressed);

    if (match){
      pr = match.r; pc = match.c;
      dots.delete(keyOf(pr,pc));
      draw();
      if (pr===exitPos.r && pc===exitPos.c) winGame();
      updateKeyboardHint();
      return;
    }

    // Optional: allow pressing "e" to enter exit if adjacent
    const exitAdj = adj.find(a => a.exit);
    if (exitAdj && pressed === "e"){
      pr = exitAdj.r; pc = exitAdj.c;
      draw();
      winGame();
    }
  }

  // ===== Drawing =====
  function cellRect(r,c,cell,ox,oy){
    return { x: ox + c*cell, y: oy + r*cell, w: cell, h: cell };
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background
    ctx.fillStyle = getCSS("--mazeBg");
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // fit cells into canvas (bigger cell size = easier to see)
    const pad = 18;
    const cell = Math.floor(Math.min(
      (canvas.width - pad*2) / cols,
      (canvas.height - pad*2) / rows
    ));
    const ox = Math.floor((canvas.width - cols*cell) / 2);
    const oy = Math.floor((canvas.height - rows*cell) / 2);

    // border
    ctx.strokeStyle = "rgba(255,255,255,.22)";
    ctx.lineWidth = 6;
    ctx.strokeRect(10,10,canvas.width-20,canvas.height-20);

    // walls
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if (!isWall(r,c)) continue;
        const {x,y,w,h} = cellRect(r,c,cell,ox,oy);

        ctx.fillStyle = getCSS("--wallGlow");
        ctx.fillRect(x-1,y-1,w+2,h+2);

        ctx.fillStyle = getCSS("--wall");
        roundRect(ctx, x+2, y+2, w-4, h-4, Math.max(6, cell*0.22));
        ctx.fill();
      }
    }

    // exit tile
    {
      const {x,y,w,h} = cellRect(exitPos.r, exitPos.c, cell, ox, oy);
      ctx.fillStyle = "rgba(255,127,158,.28)";
      roundRect(ctx, x+3, y+3, w-6, h-6, Math.max(8, cell*0.28));
      ctx.fill();
      ctx.strokeStyle = "rgba(255,127,158,.95)";
      ctx.lineWidth = 3;
      roundRect(ctx, x+6, y+6, w-12, h-12, Math.max(8, cell*0.28));
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.font = `900 ${Math.floor(cell*0.36)}px Comic Sans MS, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("EXIT", x+w/2, y+h/2);
    }

    // dots
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `900 ${Math.floor(cell*0.36)}px ui-monospace, Menlo, Consolas, monospace`;

    for (const [k,ch] of dots.entries()){
      const [r,c] = k.split(",").map(Number);
      const {x,y,w,h} = cellRect(r,c,cell,ox,oy);

      ctx.fillStyle = getCSS("--dotGlow");
      ctx.beginPath();
      ctx.arc(x+w/2, y+h/2, Math.max(6, cell*0.26), 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = getCSS("--dotText");
      ctx.fillText(String(ch).toUpperCase(), x+w/2, y+h/2);
    }

    // pacman
    drawPacman(pr,pc,cell,ox,oy);

    // highlight adjacent
    drawAdjHint(cell,ox,oy);
  }

  function drawPacman(r,c,cell,ox,oy){
    const {x,y,w,h} = cellRect(r,c,cell,ox,oy);
    const cx = x+w/2, cy = y+h/2;
    const radius = Math.max(10, cell*0.36);

    const t = Date.now()/200;
    const mouth = 0.35 + 0.12*Math.abs(Math.sin(t));

    ctx.fillStyle = getCSS("--pac");
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,radius,mouth,Math.PI*2-mouth,false);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,.65)";
    ctx.beginPath();
    ctx.arc(cx + radius*0.15, cy - radius*0.35, Math.max(2, radius*0.10), 0, Math.PI*2);
    ctx.fill();
  }

  function drawAdjHint(cell,ox,oy){
    const adj = adjacentTargets();
    if (!adj.length) return;

    for (const t of adj){
      if (!t.ch) continue;
      const {x,y,w,h} = cellRect(t.r,t.c,cell,ox,oy);
      ctx.strokeStyle = "rgba(255,255,255,.16)";
      ctx.lineWidth = 3;
      roundRect(ctx, x+5, y+5, w-10, h-10, Math.max(8, cell*0.28));
      ctx.stroke();
    }
  }

  // ===== Wire up =====
  level1Btn.addEventListener("click", () => startLevel("letters"));
  level2Btn.addEventListener("click", () => startLevel("symbols"));
  document.addEventListener("keydown", handleKey);

  // Initial preview (no timer)
  generateMaze();
  buildDots();
  pr = startPos.r; pc = startPos.c;
  draw();
  clearKeyLights();
})();
</script>
</body>
</html>
